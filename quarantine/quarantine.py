import os
import shutil
import psutil
import traceback
from datetime import datetime

# Moves file, archives it, then removes original file
# Reimplement without shutil.rmtree (suseptible to attack using symlinks)
def quarantine(filepath):
    # Make folder to archive
    archiveFolder = "toArchive"
    
    count = 1
    origFolder = archiveFolder
    while os.path.isdir(archiveFolder):
        archiveFolder = f"{origFolder} ({count})"
        count += 1
    
    try:
        os.mkdir(archiveFolder)
    except:
        pass
        
    # Make file name for archive
    storageFolder = "archivedFiles"
    try:
        os.mkdir(storageFolder)
    except:
        pass
    filename = storageFolder + "\\" + datetime.now().strftime("%m-%d-%Y %H-%M-%S")
    
    count = 1
    origFilename = filename
    while os.path.isfile(filename) or os.path.isfile(filename + ".zip"):
        filename = f"{origFilename} ({count})"
        count += 1
    
    # Move file
    attempts = 0
    while attempts < 3:
        try:
            shutil.move(filepath, archiveFolder)
            break
        except:
            freeFile(filepath)
            attempts += 1
    
    # Archive File
    shutil.make_archive(filename, "zip", archiveFolder)
    
    # Remove files
    safeDelete(archiveFolder)

# Not currently working
def freeFile(filepath):
    for process in psutil.process_iter():
        try:
            # open_files seems to always raise an psutil.AccessDenied error
            # even when running in escalated privileges
            for file in process.open_files():
                if file == filepath:
                    print(f"Attempting to kill {process.name()}")
                    try:
                        process.kill()
                    except:
                        print(f"Error killing process {process.name()}")
        except:
            pass

# Use this instead of shutil.rmtree (susceptible to symlink attack)
def safeDelete(filepath):
    failed = 0
    if os.path.isdir(filepath):
        files = os.listdir(filepath)
        # Delete files
        for file in files:
            if os.path.isfile(f"{filepath}\\{file}"):
                try:
                    os.remove(f"{filepath}\\{file}")
                except:
                    failed += 1
        # Delete folders
        for file in files:
            if os.path.isdir(f"{filepath}\\{file}"):
                safeDelete(f"{filepath}\\{file}")
        # Delete passed folder
        try:
            os.rmdir(filepath)
        except:
            failed += 1
    elif os.path.isfile(filepath):
        try:
            os.remove(file)
        except:
            failed += 1
    
    if failed > 0:
        print(f"Failed to delete {failed} files/folders")
        
if __name__ == "__main__":
    file = input("Enter path of file/folder to archive: ")
    if os.path.isfile(file) or os.path.isdir(file):
        try:
            quarantine(file)
        except:
            traceback.print_exc()
    else:
        print("Invalid file!")
