dependencies = ['sys', 'os', 'pathlib', 'string', 'psutil', 'concurrent', 'keyboard']
installDependencies(dependencies)

import sys
import os
from pathlib import Path
sys.path.insert(1, '../')
from ADD_SYS_PATHS import addSysPaths
addSysPaths()
# This is a weird problem with INSTALL_DEPENDENCIES.py where you have to install 'yara-python' but import 'yara'
from INSTALL_DEPENDENCIES import installDependencies
try:
    __import__('yara')
except ImportError:
    installDependencies(['yara-python'])
import yara
import string
import psutil
import concurrent.futures
import keyboard

#Gets Process IDs of every process running on system

def getPIDs():
    def get_pid_info(proc):
        return proc.info["pid"], proc.info["name"]

    with concurrent.futures.ThreadPoolExecutor() as executor:
        pids = dict(executor.map(get_pid_info, psutil.process_iter(attrs=["pid", "name"])))

    return pids

def badNetworkConnections():
    
    # ipsum src https://github.com/stamparm/ipsum

    # Scans traffic on network, compares to list of bad IPs, returns bad connections if they're found
    # Could be made more useful with a more extensive list of bad IPs or constant network scanning
    # 2/22 --> constant network scanning implemented
    
    IP_stats_list = []
    IP_sum = []
    bad_connections = []
    
    print("Network scan in progress...")
    print("Press any key to stop.")
    while True:
        process_connections = psutil.net_connections()
        pids = getPIDs()
        for item in process_connections:
            IP_stats = [None, None, None, None] # pid, process name, local address:port, return address:port
            item = str(item)
            if "pid=" in item:
                IP_stats[0] = item.split("pid=")[1].split(")")[0]
                IP_stats[1] = pids[int(IP_stats[0])]
            if "laddr=addr(ip'" in item:
                IP_stats[2] = item.split("laddr=addr(ip='")[1].split(")")[0].replace("', port=", ":") 
            if "raddr=addr(ip='" in item:
                IP_stats[3] = item.split("raddr=addr(ip='")[1].split(")")[0].replace("', port=", ":")
            if IP_stats[2] is not None or IP_stats[3] is not None and item not in IP_stats_list:
                IP_stats_list.append(IP_stats)
        if keyboard.read_event():
            print("Network scan stopped.")
            break
        
    for ip in IP_stats_list:
            append = False
            # This is slow, but I'm not good with multi-threading
            with open('ipsum.txt', 'r') as f: 
                if ip[2] is not None:
                    if ip[2].split(":")[0] in f.read():
                        append = True
                if ip[3] is not None:
                    if ip[3].split(":")[0] in f.read():
                        append = True 
            f.close()
            if append:
                bad_connections.append(ip)

    if not bad_connections:
        print("No bad connections found.")
        return None
    else:
        print(f"{len(bad_connections)} bad connections found!")
        for c in bad_connections:
            print(str(f"{c[1]} [PID:{c[0]}] --> Local: {c[2]}, Remote: {c[3]}").replace("Local: None, ", "").replace("Remote: None", ""))
        return bad_connections

class getCallbackData():
    #This and setCallbackData() only get the rule if the file is a match
    stored_data = None
    def YARA_callback(data):
        stored_data = data['rule']
        setCallbackData(stored_data)
        return yara.CALLBACK_CONTINUE

def setCallbackData(stored_data):
    getCallbackData.stored_data = stored_data

def YARA_PIDScan(yara_rules):
    def analyze_pid(c_pid):
        print("Analyzing ", pids[c_pid], "[", c_pid, "]")
        matches = []
        for rule_f in yara_rules:
            ext = str(rule_f).rsplit('.', 1)
            if ext[1] in ("yar", "yara"):
                fh = open(rule_f)
                rules = yara.compile(file=fh)
                fh.close()
                try:
                    rules.match(pid=c_pid, callback=getCallbackData.YARA_callback, which_callbacks=yara.CALLBACK_MATCHES)
                    if getCallbackData.stored_data is not None:
                        matches.append(getCallbackData.stored_data)
                        setCallbackData(None)
                except Exception as e:
                    print(f"Error analyzing {pids[c_pid]} [{c_pid}]: {e}")
        return matches

    matches = []
    pids = getPIDs()

    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Use executor.map to process the analyze_pid function for each process in parallel
        results = executor.map(analyze_pid, pids.keys())
        for result in results:
            matches.extend(result)

    return matches
        
def YARA_fileScan(yara_rules):
    matches = []
    filenames = fileopenbox(multiple=True)
    for file in filenames:
        print("Analyzing ", file)
        for rule_f in yara_rules:
            ext = str(rule_f).rsplit('.', 1)
            if (ext[1] == "yar" or ext[1] == "yara"):
                fh = open(rule_f)
                rules = yara.compile(file=fh)
                fh.close()
                with open(file, 'rb') as f:
                    rules.match(data = f.read(), callback = getCallbackData.YARA_callback, which_callbacks = yara.CALLBACK_MATCHES)
                    if (getCallbackData.stored_data != None):
                        matches.append(getCallbackData.stored_data)
                        setCallbackData(None)
                f.close()
            else:
                pass
            
    return matches
