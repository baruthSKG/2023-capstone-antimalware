dependencies = ['sys', 'os', 'pathlib', 'string', 'psutil', 'concurrent', 'keyboard']

import sys
import os
import time
from pathlib import Path
sys.path.insert(1, '../')
from ADD_SYS_PATHS import addSysPaths
addSysPaths()
from INSTALL_DEPENDENCIES import installDependencies
installDependencies(dependencies)
# This is a weird problem with INSTALL_DEPENDENCIES.py where you have to install 'yara-python' but import 'yara'
try:
    __import__('yara')
except ImportError:
    installDependencies(['yara-python'])
import yara
import string
import psutil
import concurrent.futures
import keyboard

#Gets Process IDs of every process running on system

def getPIDs():
    def get_pid_info(proc):
        return proc.info["pid"], proc.info["name"]

    with concurrent.futures.ThreadPoolExecutor() as executor:
        pids = dict(executor.map(get_pid_info, psutil.process_iter(attrs=["pid", "name"])))

    return pids

def badNetworkConnections():
    
    # ipsum src https://github.com/stamparm/ipsum

    # Scans traffic on network, compares to list of bad IPs, returns bad connections if they're found
    # Could be made more useful with a more extensive list of bad IPs or constant network scanning
    # 2/22 --> constant network scanning implemented
    
    IP_stats_list = []
    IP_sum = []
    bad_connections = []
    IP_add_hosts = []

    scan_start_time = time.time()
    scan_end_time = time.time()
    SCAN_TIME = 5
    
    print("Network scan in progress...")
    print(f"(Scan will automatically stop after {SCAN_TIME} seconds)")
    while scan_end_time - scan_start_time < SCAN_TIME:
        scan_end_time = time.time()
        process_connections = psutil.net_connections()
        pids = getPIDs()
        for item in process_connections:
            IP_stats = [None, None, None, None] # pid, process name, local address:port, return address:port
            item = str(item)
            if "pid=" in item:
                IP_stats[0] = item.split("pid=")[1].split(")")[0]
                IP_stats[1] = pids[int(IP_stats[0])]
            if "laddr=addr(ip'" in item:
                IP_stats[2] = item.split("laddr=addr(ip='")[1].split(")")[0].replace("', port=", ":") 
            if "raddr=addr(ip='" in item:
                IP_stats[3] = item.split("raddr=addr(ip='")[1].split(")")[0].replace("', port=", ":")
            if IP_stats[2] is not None and not IP_stats[2].startswith("::") or IP_stats[3] is not None and not IP_stats[3].startswith("::") and IP_stats not in IP_stats_list:
                IP_stats_list.append(IP_stats)
        #if keyboard.read_event():
        #    break
        
    print("Network scan stopped. Loading results...")    
    for ip in IP_stats_list:
            append = False
            # This is slow, but I'm not good with multi-threading
            with open('ipsum.txt', 'r') as f:
                if ip[2] is not None:
                    if ip[2].split(":")[0] in f.read():
                        append = True
                        if ip[2].split(":")[0] not in IP_add_hosts:
                            IP_add_hosts.append(ip[2].split(":")[0])
                if ip[3] is not None:
                    if ip[3].split(":")[0] in f.read():
                        append = True
                        if ip[3].split(":")[0] not in IP_add_hosts:
                            IP_add_hosts.append(ip[3].split(":")[0])
            f.close()
            if append:
                bad_connections.append(ip)
    print("\n")
    if not bad_connections:
        print("No bad connections found.")
        return None
    else:
        print(f"{len(bad_connections)} bad connections found!")
        for c in bad_connections:
            print(str(f"{c[1]} [PID:{c[0]}] --> Local: {c[2]}, Remote: {c[3]}").replace("Local: None, ", "").replace("Remote: None", ""))
        SAFE_MODE = True
        SAFE_MODE_CHOICE = ""
        print("\n")
        print("Safe mode is currently on!\nYou won't be able to kill processes or block IPs in the Windows Hosts file.")
        while SAFE_MODE_CHOICE not in ['Y', 'N']:
               SAFE_MODE_CHOICE = input("Turn safe mode off? [Y/N] --> ").upper()
        if SAFE_MODE_CHOICE == "Y":
            SAFE_MODE = False
        if not SAFE_MODE:
            choice = 0
            print("\n")
            print("Options:")
            print("[1] Kill processes and block IPs")
            print("[2] Kill processes")
            print("[3] Block IPs")
            print("[4] Ignore")
            while choice not in range(1, 5):
                choice = int(input("Choice --> "))
            if choice == 1 or choice == 2:
                for c in bad_connections:
                    psutil.Process(int(c)).terminate()
            # This will write to the Windows hosts file and resolve the bad IP to 127.0.0.1
            # Requires running script with administrator permissions or else Errno 13
            # Careful while testing since this can mess up network connections if there's a false positive
            if choice == 1 or choice == 3:
                with open("C:\Windows\System32\drivers\etc\hosts", "a") as h:
                    h.write("\n# BONFIRE SECURITY SCAN\n")
                    for i in IP_add_hosts:
                        h.write(f"127.0.0.1      {i}")
                h.close()
        return bad_connections

class getCallbackData():
    #This and setCallbackData() only get the rule if the file is a match
    stored_data = None
    def YARA_callback(data):
        stored_data = data['rule']
        setCallbackData(stored_data)
        return yara.CALLBACK_CONTINUE

def setCallbackData(stored_data):
    getCallbackData.stored_data = stored_data

def YARA_PIDScan(yara_rules):
    def analyze_pid(c_pid):
        print("Analyzing ", pids[c_pid], "[", c_pid, "]")
        matches = []
        for rule_f in yara_rules:
            ext = str(rule_f).rsplit('.', 1)
            if ext[1] in ("yar", "yara"):
                fh = open(rule_f)
                rules = yara.compile(file=fh)
                fh.close()
                try:
                    rules.match(pid=c_pid, callback=getCallbackData.YARA_callback, which_callbacks=yara.CALLBACK_MATCHES)
                    if getCallbackData.stored_data is not None:
                        matches.append(getCallbackData.stored_data)
                        setCallbackData(None)
                except Exception as e:
                    print(f"Error analyzing {pids[c_pid]} [{c_pid}]: {e}")
        return matches

    matches = []
    pids = getPIDs()

    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Use executor.map to process the analyze_pid function for each process in parallel
        results = executor.map(analyze_pid, pids.keys())
        for result in results:
            matches.extend(result)

    return matches
        
def YARA_fileScan(yara_rules):
    matches = []
    filenames = fileopenbox(multiple=True)
    for file in filenames:
        print("Analyzing ", file)
        for rule_f in yara_rules:
            ext = str(rule_f).rsplit('.', 1)
            if (ext[1] == "yar" or ext[1] == "yara"):
                fh = open(rule_f)
                rules = yara.compile(file=fh)
                fh.close()
                with open(file, 'rb') as f:
                    rules.match(data = f.read(), callback = getCallbackData.YARA_callback, which_callbacks = yara.CALLBACK_MATCHES)
                    if (getCallbackData.stored_data != None):
                        matches.append(getCallbackData.stored_data)
                        setCallbackData(None)
                f.close()
            else:
                pass
            
    return matches
