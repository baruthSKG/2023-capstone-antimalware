dependencies = ['hashlib','zlib','os','glob','pathlib','tkinter','easygui','sqlite3', 'customtkinter', 'shutil', 'psutil', 'traceback', 'datetime', 'pandas']

import sys
sys.path.insert(1, '../')
from INSTALL_DEPENDENCIES import installDependencies
installDependencies(dependencies)
sys.path.insert(1, '../quarantine')
from quarantine import *
sys.path.insert(1, '../logging')
from logFunctions import *

import ctypes
import sys
import hashlib
import zlib
import os
import glob
import pathlib
import concurrent.futures
import customtkinter as ct
from tkinter import filedialog
import tkinter as tk
from easygui import *
import sqlite3
import threading
import string
import pandas as pd
from time import gmtime, strftime

cwd = os.getcwd() # need this to chdir back into the directory with HashDB.db, otherwise it won't be able to find it, HashDB.db should ALWAYS be in the same directory as this file

def getHashMD5(filename):
    md5_hash = hashlib.md5()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            md5_hash.update(byte_block)
        return md5_hash.hexdigest()
    f.close()

def getHashCRC32(filename):
    prev = 0
    for line in open(filename,"rb"):
        prev = zlib.crc32(line, prev)
    crc32_hash = "%X"%(prev & 0xFFFFFFFF)
    return crc32_hash
    rb.close()

def getHashSHA1(filename):
    sha1_hash = hashlib.sha1()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha1_hash.update(byte_block)
        return sha1_hash.hexdigest()
   

def getHashSHA256(filename):
    sha256_hash = hashlib.sha256()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

def getHashSHA384(filename):
    sha384_hash = hashlib.sha384()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha384_hash.update(byte_block)
        return sha384_hash.hexdigest()

def getHashSHA512(filename):
    sha512_hash = hashlib.sha512()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha512_hash.update(byte_block)
        return sha512_hash.hexdigest()
       
def compareHashDB_SQLite(file_hash):
    # Open SQLite database
    connection = sqlite3.connect(cwd + '/HashDB.db')
    cursor = connection.cursor()
    databases = ['HashDB'] # in case we need multiple databases
    for db in databases:
        cursor.execute('SELECT name FROM ' + db + ' WHERE hash=?', (file_hash,))
    output = cursor.fetchone()
    if (output != None):
        for row in output:
            return row
    else:
        return "No infections found!"
        
    connection.commit()
    connection.close()

# Data from https://bazaar.abuse.ch/export/ (csv, full data dump)
def compareMalwareBazaar(sha256_hash, md5_hash, sha1_hash):
    # Read and trim file
    df = pd.read_csv('full.csv', skiprows=8, quotechar='"', skipinitialspace = True, keep_default_na=False, na_values=None)
    df.drop(df.tail(1).index, inplace=True)
    
    # Get results that match any passed hash
    query = f"sha256_hash == '{sha256_hash}' or "
    query += f"md5_hash == '{md5_hash}' or "
    query += f"sha1_hash == '{sha1_hash}'"
    results = df.query(query)
    
    # Return result (if returning "n/a", a match was found with no name)
    if len(results) > 0:
        return results['signature'].iloc[0]
    else:
        return "No infections found!"

def checkDBs(md5_hash, sha256_hash, sha1_hash):
            result = "No infections found!"
            if (compareHashDB_SQLite(md5_hash) != result):
                result = compareHashDB_SQLite(md5_hash)
            #if (compareMalwareBazaar(sha256_hash, md5_hash, sha1_hash) != result):
            #    result = compareMalwareBazaar(sha256_hash, md5_hash, sha1_hash)
            return result

whitelisted_files = []
whitelist_lock = threading.Lock()

def add_to_whitelist(file_path):
    with whitelist_lock:
        whitelisted_files.append(file_path)
    print(f"'{file_path}' has been whitelisted and will not be scanned.")


def fileScan(timestamp,file_path):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)

    if file_path in whitelisted_files:
        print(f"'{file_path}' is whitelisted and will not be scanned.")
        errorLog(timestamp,file_path,"File is whitelisted")
        return
    try:
        print("Scanning file --> " + file_path)
        md5_hash = getHashMD5(file_path)
        sha256_hash = getHashSHA256(file_path)
        sha1_hash = getHashSHA1(file_path)
        result = checkDBs(md5_hash, sha256_hash, sha1_hash)
        scanLog(timestamp, file_path)

        if result != "No infections found!":
            found_infections[file_path] = result
        print("\nFOUND INFECTIONS:")
        if not found_infections:
            print("No infections found!")
        else:
            for key, value in found_infections.items():
                print(f"[{key}] --> {value}")
            actions = scanResultsAndActions(found_infections)
    except Exception as e:
        print(f"FAILED TO SCAN FILE '{file_path}': {e}")
        errorLog(timestamp,file_path,e)

def folderScan(timestamp,folder_path):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                # Check if the file is whitelisted
                if file_path in whitelisted_files:
                    print(f"'{file_path}' is whitelisted and will not be scanned.")
                    errorLog(timestamp,file_path,"File is whitelisted")
                    continue  # Skip scanning whitelisted files
                # Perform scanning for non-whitelisted files
                print("Scanning file --> " + file_path)
                md5_hash = getHashMD5(file_path)
                sha256_hash = getHashSHA256(file_path)
                sha1_hash = getHashSHA1(file_path)
                result = checkDBs(md5_hash, sha256_hash, sha1_hash)
                scanLog(timestamp, file_path)
                if result != "No infections found!":
                    found_infections[file_path] = result
            except Exception as e:
                print(f"FAILED TO SCAN FILE '{file_path}': {e}")
                errorLog(timestamp,file_path,e)
    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
        actions = scanResultsAndActions(found_infections)
            
            
#added multi-threaded support but RAM hungry
def fullSystemScan(timestamp):
    global found_infections
    found_infections = {}  #Dictionary to store found infections (file_path: malware_name)
    
    with concurrent.futures.ThreadPoolExecutor() as executor:
        for root, dirs, files in os.walk('/', topdown=True):
            for file in files:
                file_path = os.path.join(root, file)
                executor.submit(fileScan, timestamp, file_path)

    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
        actions = scanResultsAndActions(found_infections)

#Takes from the user and returns a list of actions taken for each infection
def scanResultsAndActions(found_infections):
    inf_actions = []
    print("\nFOUND INFECTIONS:")
    if found_infections == {}:
        print("No infections found!") 
    else:
        confirm = 0
        app_check = 0
        while (confirm != 999):
            count = 0
            actions = ['Delete', 'Keep', 'Quarantine']
            for key in found_infections:
                if (app_check == 0):
                    inf_actions.append(actions[0])
                print('[', count, ']', '[', inf_actions[count], ']', found_infections[key], '<--', key)
                count = count + 1
            
            print("\n")
            print("ACTIONS:")
            print("-------------------")
            print("[1] Delete All | [2] Delete One/Multiple | [3] Keep All | [4] Keep One/Multiple | [5] Quarantine All | [6] Quarantine One/Multiple")
            print("\n")
            print("[999] Confirm")
            print("\n")
            confirm = input("Choice --> ")
            confirm = int(confirm)
            app_check = 1
            if (confirm % 2 != 0):
                count = 0
                for inf in inf_actions:
                    if (confirm == 1):
                        inf_actions[count] = actions[0]
                    elif (confirm == 3):
                        inf_actions[count] = actions[1]
                    elif (confirm == 5):
                        inf_actions[count] = actions[2]
                    count += 1
            elif (confirm % 2 == 0):
                if (confirm == 2):
                    mult_keyword = "delete"
                elif (confirm == 4):
                    mult_keyword = "keep"
                elif (confirm == 6):
                    mult_keyword = "quarantine"
                print("Enter one or multiple files to", mult_keyword)
                print("(Multiple files separated by comma --> Ex. 1,3,5,7)")
                print("-1 to exit")
                print("\n")
                if (confirm == -1):
                    pass
                else:
                    tmp_list_choice = []
                    tmp_list_choice = input("Choice --> ")
                    tmp_list = tmp_list_choice.split(',')
                    tmp_list = [eval(i) for i in tmp_list]
                    count = 0
                    i = 0
                    for inf in inf_actions:
                        # ??????? This only works with a try/else statement and I don't know why        
                        try:
                            if (count == tmp_list[i]):
                                if (confirm == 2):
                                    inf_actions[count] = actions[0]
                                elif (confirm == 4):
                                    inf_actions[count] = actions[1]
                                elif (confirm == 6):
                                    inf_actions[count] = actions[2]
                                i = i + 1
                            count = count + 1
                        except:
                            pass 
        count = 0
        for key in found_infections:
            if (inf_actions[count] == 'Delete'):
                print("Deleting infection", found_infections[key], "--> (", key, ")")
                os.chdir('C:/')
                if os.path.exists(key):
                  os.remove(key)
                infectionLog(timestamp,key,found_infections[key],inf_actions[count])
            elif (inf_actions[count] == 'Quarantine'):
                print("Quarantining infection", found_infections[key], "--> (", key, ")")
                quarantine(key)
                infectionLog(timestamp,key,found_infections[key],inf_actions[count])
            elif (inf_actions[count] == 'Keep'):
                print("Keeping infection", found_infections[key], "--> (", key, ")")
                infectionLog(timestamp,key,found_infections[key],inf_actions[count])
            count += 1
            
    return inf_actions
        
            
def dbTests():
    file_hash = '38c07fde8a4d0c51ed48a80ee0931b62'
    assert(compareHashDB_SQLite(file_hash) == "Trojan.JS.Cryxos")
    file_hash = '320e465e96fac3eaecbc63ea78ac70f6'
    assert(compareHashDB_SQLite(file_hash) == "W32/Emotet.AWL.gen!Eldorado")
    file_hash = "2533c4d575099795fd7a86f5a37ce3511573c23f06bb22a6dfcc60e9490ccadb" #SHA256
    assert(compareMalwareBazaar(file_hash, "", "") == "QuasarRAT")
    file_hash = "d8f2cb03278f0f90ed77bf974ac1f81b" #MD5
    assert(compareMalwareBazaar("", file_hash, "") == "Gafgyt")
    file_hash = "2de743345cf42ba0e92c02240c58625e7aeb45a3" #SHA1
    assert(compareMalwareBazaar("", "", file_hash) == "n/a") # Some entries in MalwareBazaar don't have names associated
    file_hash = "Fake hash"
    assert(compareMalwareBazaar(file_hash, file_hash, file_hash) == "No infections found!")
    assert(compareMalwareBazaar("", "", "") == "No infections found!")
    
            
def exitProgram():
    exit()

def main():
    #dbTests()
    #|--------------------GUI--------------------|
    ct.set_appearance_mode("dark")
    ct.set_default_color_theme("green")
    root = ct.CTk()
    root.geometry("800x600")
    root.title("Anti-Malware Program")
    frame = ct.CTkFrame(master=root)
    frame.pack(pady=20, padx=60, fill="both", expand=True)

    labelOne = ct.CTkLabel(master=frame, text="Get started by scanning specific files, a folder, or the entire system.")
    labelTwo = ct.CTkLabel(master=frame, text="WARNING: Files that require admin rights or are in use by the system might not be scanned!")
    labelOne.pack(pady=12, padx=10)
    labelTwo.pack(pady=12, padx=10)
    
    entry = ct.CTkEntry(master=frame, placeholder_text="File path to scan:")
    entry.pack(pady=12, padx=10)

    def fileScanPath(event=None):
        file_path = entry.get()
        if os.path.exists(file_path):
            timestamp = strftime("%m-%d-%Y %H %M %S", gmtime())
            fileScan(file_path)
        else:
            print("Invalid file path. Please enter a valid path.")

    def fileScanAction():
        file_path = filedialog.askopenfilename()  #File Scan action
        if file_path:
            timestamp = strftime("%m-%d-%Y %H %M %S", gmtime())
            fileScan(timestamp,file_path)
            
    def folderScanAction():
        folder_path = filedialog.askdirectory()  #Folder Scan action
        if folder_path:
            timestamp = strftime("%m-%d-%Y %H %M %S", gmtime())
            folderScan(timestamp,folder_path)
            
    def fullSystemScanAction():                  #Full System Scan action
        timestamp = strftime("%m-%d-%Y %H %M %S", gmtime())
        fullSystemScan(timestamp)
        
    def addToWhitelistAction():
        file_path = filedialog.askopenfilename()
        if file_path:
            add_to_whitelist(file_path)
        
    entry.bind("<Return>", fileScanPath)
    
    
    #File Scan Button
    fileScanButton = ct.CTkButton(master=frame, text="File Scan", command=fileScanAction)
    fileScanButton.pack(pady=12, padx=10)
    
    #folder scan button
    folderScanButton = ct.CTkButton(master=frame, text="Folder Scan", command=folderScanAction)
    folderScanButton.pack(pady=12, padx=10)
    
    #system scan button
    systemScanButton = ct.CTkButton(master=frame, text="Full System Scan", command=fullSystemScanAction)
    runningLabel = ct.CTkLabel(master=frame, text="scanning all files...")
    systemScanButton.pack(pady=12, padx=10)
    
    #Whitelist button
    addToWhitelistButton = ct.CTkButton(master=frame, text="Add to Whitelist", command=addToWhitelistAction)
    addToWhitelistButton.pack(pady=12, padx=10)

    #exit button
    exitButton = ct.CTkButton(master=frame, text="Exit", command=exitProgram)
    exitButton.pack(pady=12, padx=10)

    root.mainloop()
    #|--------------------end of GUI--------------------|
    
def run_as_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        return True
    # If not admin, request admin privileges and re-run the script
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    return False

if run_as_admin():
    print("Running with administrative privileges...")
    main()
