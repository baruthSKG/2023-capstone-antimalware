import sys
sys.path.insert(1, '../')
from ADD_SYS_PATHS import addSysPaths
addSysPaths()
from INSTALL_DEPENDENCIES import installDependencies
from HASH_FUNCTIONS import *
from DB_FUNCTIONS import *
from scan_results_and_actions import *
from quarantine import *
from logFunctions import *

dependencies = ['hashlib','zlib','os','glob','pathlib','tkinter','easygui','sqlite3', 'customtkinter']

import pip
installDependencies(dependencies)
import ctypes
import hashlib
import zlib
import os
import glob
import pathlib
import concurrent.futures
import customtkinter as ct
import tkinter as tk
import sqlite3
import threading
from mainGUI import GUI
import string
import pandas as pd
from time import gmtime, strftime

whitelisted_files = []
whitelist_lock = threading.Lock()

def add_to_whitelist(file_path):
    with whitelist_lock:
        whitelisted_files.append(file_path)
    print(f"'{file_path}' has been whitelisted and will not be scanned.")


def fileScan(timestamp,file_path,flag):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)

    if file_path in whitelisted_files:
        print(f"'{file_path}' is whitelisted and will not be scanned.")
        errorLog(timestamp,file_path,"File is whitelisted")
        return
    try:
        file_hash = getHashMD5(file_path)
        print(f"SCANNING --> {file_path}")
        result = compareHashDB_SQLite(file_hash)
        scanLog(timestamp, file_path)
        if result != "No infections found!":
            found_infections[file_path] = result
        if flag != 1:
            print("\nFOUND INFECTIONS:")
            if not found_infections:
                print("No infections found!")
            else:
                for key, value in found_infections.items():
                    print(f"[{key}] --> {value}")
                actions = scanResultsAndActions(found_infections)
            
    except Exception as e:
        print(f"FAILED TO SCAN FILE '{file_path}': {e}")
        errorLog(timestamp,file_path,e)

def folderScan(timestamp,folder_path):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                # Check if the file is whitelisted
                if file_path in whitelisted_files:
                    print(f"'{file_path}' is whitelisted and will not be scanned.")
                    errorLog(timestamp,file_path,"File is whitelisted")
                    continue  # Skip scanning whitelisted files
                # Perform scanning for non-whitelisted files
                file_hash = getHashMD5(file_path)
                print(f"SCANNING --> {file_path}")
                result = compareHashDB_SQLite(file_hash)
                scanLog(timestamp, file_path)
                if result != "No infections found!":
                    found_infections[file_path] = result
            except Exception as e:
                print(f"FAILED TO SCAN FILE '{file_path}': {e}")
                errorLog(timestamp,file_path,e)
    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
        actions = scanResultsAndActions(found_infections)
            
            
def fullSystemScan(timestamp):
    #global found_infections
    found_infections = {}  
    
    total_threads = 10  # Set the maximum number of concurrent threads
    batch_size = 100  # Set the number of files to process in each batch
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=total_threads) as executor:
        for root, dirs, files in os.walk('/', topdown=True):
            file_paths = [os.path.join(root, file) for file in files]
            for i in range(0, len(file_paths), batch_size):
                batch = file_paths[i:i+batch_size]
                for file in batch:
                    executor.submit(fileScan, timestamp, file, 1)


    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
    
            
def exitProgram():
    exit()
    
    
def run_as_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        return True
    # If not admin, request admin privileges and re-run the script
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    return False

#if run_as_admin():
#    print("Running with administrative privileges...")
#    GUI()

def main():
    GUI()

if __name__ == "__main__":
    main()
