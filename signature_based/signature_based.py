dependencies = ['hashlib','zlib','os','glob','pathlib','tkinter','easygui','sqlite3', 'customtkinter']

import pip
for item in dependencies:
    try:
        __import__(item)
    except ImportError:
        print("Installing dependency --> ", item) 
        pip.main(['install', item])
import ctypes
import sys
import hashlib
import zlib
import os
import glob
import pathlib
import concurrent.futures
import customtkinter as ct
import tkinter as tk
#from easygui import *
import sqlite3
import threading
from mainGUI import GUI

cwd = os.getcwd() # need this to chdir back into the directory with HashDB.db, otherwise it won't be able to find it, HashDB.db should ALWAYS be in the same directory as this file

def getHashMD5(filename):
    with open(filename, "rb") as f:
        md5_hash = hashlib.md5()
        for byte_block in iter(lambda: f.read(4096), b""):
            md5_hash.update(byte_block)
        return md5_hash.hexdigest()

def getHashCRC32(filename):
    prev = 0
    with open(filename, "rb") as f:
        for line in f:
            prev = zlib.crc32(line, prev)
    crc32_hash = "%X" % (prev & 0xFFFFFFFF)
    return crc32_hash

def getHashSHA1(filename):
    with open(filename, "rb") as f:
        sha1_hash = hashlib.sha1()
        for byte_block in iter(lambda: f.read(4096), b""):
            sha1_hash.update(byte_block)
        return sha1_hash.hexdigest()

def getHashSHA256(filename):
    with open(filename, "rb") as f:
        sha256_hash = hashlib.sha256()
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

def getHashSHA384(filename):
    with open(filename, "rb") as f:
        sha384_hash = hashlib.sha384()
        for byte_block in iter(lambda: f.read(4096), b""):
            sha384_hash.update(byte_block)
        return sha384_hash.hexdigest()

def getHashSHA512(filename):
    sha512_hash = hashlib.sha512()
    with open(filename,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha512_hash.update(byte_block)
        return sha512_hash.hexdigest()
    f.close()
       
def compareHashDB_SQLite(file_hash):
    # Open SQLite database
    connection = sqlite3.connect(cwd + '/HashDB.db')
    cursor = connection.cursor()
    databases = ['HashDB'] # in case we need multiple databases
    for db in databases:
        cursor.execute('SELECT name FROM ' + db + ' WHERE hash=?', (file_hash,))
    output = cursor.fetchone()
    if (output != None):
        for row in output:
            return row
    else:
        return "No infections found!"
        
    connection.commit()
    connection.close()


whitelisted_files = []
whitelist_lock = threading.Lock()

def add_to_whitelist(file_path):
    with whitelist_lock:
        whitelisted_files.append(file_path)
    print(f"'{file_path}' has been whitelisted and will not be scanned.")


def fileScan(file_path):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)

    if file_path in whitelisted_files:
        print(f"'{file_path}' is whitelisted and will not be scanned.")
        return
    try:
        file_hash = getHashMD5(file_path)
        result = compareHashDB_SQLite(file_hash)
        if result != "No infections found!":
            found_infections[file_path] = result
        print("\nFOUND INFECTIONS:")
        if not found_infections:
            print("No infections found!")
        else:
            for key, value in found_infections.items():
                print(f"[{key}] --> {value}")
    except Exception as e:
        print(f"FAILED TO SCAN FILE '{file_path}': {e}")


def folderScan(folder_path):
    found_infections = {}  # Dictionary to store found infections (file_path: malware_name)
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                # Check if the file is whitelisted
                if file_path in whitelisted_files:
                    print(f"'{file_path}' is whitelisted and will not be scanned.")
                    continue  # Skip scanning whitelisted files
                # Perform scanning for non-whitelisted files
                file_hash = getHashMD5(file_path)
                result = compareHashDB_SQLite(file_hash)
                if result != "No infections found!":
                    found_infections[file_path] = result
            except Exception as e:
                print(f"FAILED TO SCAN FILE '{file_path}': {e}")
    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
            
            
#added multi-threaded support but RAM hungry
def fullSystemScan():
    global found_infections
    found_infections = {}  #Dictionary to store found infections (file_path: malware_name)
    
    def scan_file(file_path):
            try:
                fileScan(file_path)
            except Exception as e:
                print(f"FAILED TO SCAN FILE '{file_path}': {e}")
    with concurrent.futures.ThreadPoolExecutor() as executor:
        for root, dirs, files in os.walk('/', topdown=True):
            for file in files:
                file_path = os.path.join(root, file)
                executor.submit(fileScan, file_path)

    print("\nFOUND INFECTIONS:")
    if not found_infections:
        print("No infections found!")
    else:
        for key, value in found_infections.items():
            print(f"[{key}] --> {value}")
    
            
def exitProgram():
    exit()
    
    
def run_as_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        return True
    # If not admin, request admin privileges and re-run the script
    ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
    return False

#if run_as_admin():
#    print("Running with administrative privileges...")
#    GUI()

def main():
    GUI()

if __name__ == "__main__":
    main()
